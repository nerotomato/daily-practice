# 1.JVM默认堆内存大小
1.机器内存16,最大堆内存默认为内存的4分之1，4g <br> 
2.机器内存小于1g,最大堆内存默认为内存的2分之1,512m <br>

# 2.各种GC垃圾回收器对比

##2.1.串行GC(Serial GC)
###2.1.1.GC算法
年轻代使用 mark-copy（标记-复制）算法，老年代使用 mark-sweep-compact（标记-清除-整理）算法。<br>
###2.1.2.GC特点
单线程的垃圾收集器，不能进行并行处理，年轻代和老年代的垃圾回收都会触发全线暂停（STW）.<br>
###2.1.3.启动参数
-XX:+UseSerialGC<br>
###2.1.4.适用范围
适合单核CPU，几百兆堆内存大小的JVM使用。

##2.2.并行GC(Parallel GC)
###2.2.1.GC算法
年轻代使用mark-copy（标记-复制）算法，老年代使用 mark-sweep-compact（标记-清除-整理）算法。<br>
###2.2.2.GC特点
多线程的垃圾回收器，年轻代和老年代的垃圾回收都会触发全线暂停（STW）.
由于使用多线程进行垃圾回收，并行执行，使得GC时间大幅减少。<br>
###2.2.3.启动参数
三组任意一组都可以，-XX:+UseParallelGC;
-XX:+UseParallelOldGC;
-XX:+UseParallelGC -XX:+UseParallelOldGC<br>
指定GC线程数命令：-XX:ParallelGCThreads=NNN，默认值为CPU核心数
###2.2.4.适用范围
适合多核CPU，主要目标是增加吞吐量。由于在GC期间，所有CPU内核都在并行清理垃圾，所以总暂停时间更短。

##2.3.CMS垃圾收集器（Mostly Concurrent Mark and Sweep Garbage Collector 最大并发-标记-清除-垃圾收集器）
###2.3.1.GC算法
年轻代使用**并行mark-copy**（标记-复制）算法，老年代使用**并发 mark-sweep** (标记-清除)算法
###2.3.2.GC特点
设计目标：是避免在老年代垃圾收集时出现长时间的卡顿。主要通过两种手段来达成此目标：
第一，不对老年代进行整理，而是使用空闲列表(free-lists)来管理内存空间的回收
第二，在 mark-and-sweep (标记-清除) 阶段的大部分工作和应用线程一起并发执行。
默认情况下，CMS使用的并发线程数等于CPU核心数的1/4 。
###2.3.3.启动参数
-XX:+UseConcMarkSweepGC
###2.3.4.适用范围
适合多核CPU，主要调优目标是降低GC停顿导致的系统延迟。
因为多数时候都有部分CPU资源被GC消耗，所以在CPU资源受限的情况下，CMS GC会比并行GC的吞吐量差一些
（对于绝大部分系统， 这个吞吐和延迟的差别应该都不明显）。
###2.3.5.CMS GC的几个阶段
####阶段 1: Initial Mark(初始标记)
这个阶段伴随着STW暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻
代中所有存活对象所引用的对象（老年代单独回收）。
####阶段 2: Concurrent Mark(并发标记)
在此阶段，CMS GC遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算 起。
“并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。
请注意，并非所有老年代中存活的对象都在此阶段被标记，因为在标记过程中对象的引用关系还在发生变化。
####阶段 3: Concurrent Preclean(并发预清理)
此阶段同样是与应用线程并发执行的，不需要停止应用线程。
因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。
如果在并发标记过程中引用关系发生了变化，JVM会通过“ Card（卡片） ”的方式将发生了改变的区域标记为“脏”区，这就是所谓
的卡片标记（Card Marking）。在预清理阶段，这些脏对象会被统计出来，他们**所引用的对象也会被标记**。
此阶段完成后，用以标记的 card 也就会被清空。此阶段也会进行一些必要的细节处理，还会为 Final Remark 阶段做一些准备工作。<br>

**个人理解:** 此阶段也相当于是标记阶段，标记存活对象，统计上个阶段（并发标记）标记的脏对象，标记他们所引用的对象，确认脏对象是否是存活对象。
最后清理上一个阶段：并发标记阶段标出的card。<br>

####阶段 4: Concurrent Abortable Preclean(可取消的并发预清理)
此阶段也不停止应用线程。本阶段尝试在 STW 的 Final Remark阶段 之前尽可能地多做一些工作。本阶段的 具体时间取决于多种因素，因为它循环做同样的事情，直到满足某个退出条件( 如迭代次数，有用工作量， 消耗的系统时间等等)。
此阶段可能显著影响STW停顿的持续时间，并且有许多重要的配置选项和失败模式。
####阶段 5: Final Remark(最终标记)
最终标记阶段是此次GC事件中的第二次(也是最后一次)STW停顿。 本阶段的目标是完成老年代中所有存活对象的标记. 因为之前的预清理阶段是并发执行的，有可能GC线程跟
不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常CMS会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。
在5个标记阶段完成之后，老年代中所有的**存活对象**都被标记了，
然后GC将在下个阶段清除所有不使用的对象来回收老年代空间。
####阶段 6: Concurrent Sweep(并发清除)
此阶段与应用程序并发执行，不需要STW停顿。JVM在此阶段删除不再使用的对象，并回收他们占用的内存空间。
####阶段 7: Concurrent Reset(并发重置)
此阶段与应用程序并发执行，重置CMS算法相关的内部数据，为下一次GC循环做准备。 总之，CMS垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。
当然，CMS也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为 不压缩，不整理），在某些情况下GC会造成不可预测的暂停时间，特别是堆内存较大的情况下。

##2.4.G1垃圾收集器(Garbage-First)
###2.4.1.设计目标
将STW停顿的时间和分布，变成可预期且可配置的。<br>
事实上，G1 GC是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。例如可以指定: 在任意 xx
毫秒时间范围内，STW停顿不得超过 yy 毫秒。 举例说明: 任意 1秒 内暂停时间不超过 5毫秒 。
G1 GC 会尽力达成这个目标（有很大概率会满足，但并不完全确定）。
###2.4.2.GC特点
为了达成可预期停顿时间的指标，G1 GC有一些独特的实现。
首先，堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的小块堆区域
(smaller heap regions)。 每个小块，可能一会被定义成 Eden 区，一会被指定为Survivor区或者Old 区。<br>
在逻辑上，所有的Eden区和Survivor区合起来就是年轻代，所有的Old区拼在一起那就是老年代。<br>
这样划分之后，使得 G1不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内
存块，称为此次GC的回收集(collection set)。每次GC暂停都会收集所有年轻代的内存块，但一般只包含部
分老年代的内存块。<br>
G1的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。
构建回收集的原则是： 垃圾最多的小块 会被优先收集。这也是G1名称的由来。
###2.4.3.启动参数
-XX:+UseG1GC -XX:MaxGCPauseMills=50
###2.4.4.常用参数
-XX:+UseG1GC ：启用G1 GC，JDK7和JDK8要求必须显示申请启动G1 GC；<br>
-XX:G1NewSizePercent ：初始年轻代占整个Java Heap的大小，默认值为5%；<br>
-XX:G1MaxNewSizePercent ：最大年轻代占整个Java Heap的大小，默认值为60%；<br>
-XX:G1HeapRegionSize ：设置每个Region的大小，单位MB，需要为1，2，4，8，16，32中的某 个值，默认是堆内存的1/2000。如果这个值设置比较大，那么大对象就可以进入Region了。<br>
-XX:ConcGCThreads ：与Java应用一起执行的GC线程数量，默认是Java线程的1/4，减少这个参 数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程 不足，也会导致并行回收机制耗时加长。<br>
**-XX:+InitiatingHeapOccupancyPercent （简称IHOP）**：G1内部并行回收循环启动的阈值， 默认为Java Heap的45%。这个可以理解为老年代使用大于等于45%的时候，JVM会启动垃圾回收。这 个值非常重要，它决定了在什么时间启动老年代的并行回收。<br>
-XX:G1HeapWastePercent ：G1停止回收的最小内存大小，默认是堆大小的5%。GC会收集所有 的Region中的对象，但是如果下降到了5%，就会停下来不再收集了。就是说，不必每次回收就把所有 的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间。<br>
-XX:G1MixedGCCountTarget ：设置并行循环之后需要有多少个混合GC启动，默认值是8个。老 年代Regions的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许G1 延长老年代的收集时间。<br>
-XX:+G1PrintRegionLivenessInfo ：这个参数需要和 -
XX:+UnlockDiagnosticVMOptions 配合启动，打印JVM的调试信息，每个Region里的对象存活 信息。<br>
-XX:G1ReservePercent ：G1为了保留一些空间用于年代之间的提升，默认值是堆空间的10%。 因为大量执行回收的地方在年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、 比较多的大对象存活，这里需要保留一些内存。<br>
-XX:+G1SummarizeRSetStats ：这也是一个VM的调试信息。如果启用，会在VM退出的时候打印 出RSets的详细总结信息。如果启用 -XX:G1SummaryRSetStatsPeriod 参数，就会阶段性地打印 RSets信息。
-XX:+G1TraceConcRefinement ：这个也是一个VM的调试信息，如果启用，并行回收阶段的日志 就会被详细打印出来。<br>
-XX:+GCTimeRatio ：大家知道，GC的有些阶段是需要Stop-the-World，即停止应用线程的。这个参数就是计算花在Java应用线程上和花在GC线程上的时间比率，默认是9，跟新生代内存的分配比例 一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1的计算公式是100/ （1+GCTimeRatio）。这样如果参数设置为9，则最多10%的时间会花在GC工作上面。Parallel GC的 默认值是99，表示1%的时间被用在GC上面，这是因为Parallel GC贯穿整个GC，而G1则根据Region 来进行划分，不需要全局性扫描整个内存堆。<br>
-XX:+UseStringDeduplication ：手动开启Java String对象的去重工作，这个是JDK8u20版本 之后新增的参数，主要用于相同String避免重复申请内存，节约Region的使用。<br>
-XX:MaxGCPauseMills ：预期G1每次执行GC操作的暂停时间，单位是毫秒，默认值是200毫秒， G1会尽量保证控制在这个范围内。<br>
###2.4.5.重要参数
XX:+UseG1GC 启用G1 GC；<br>
-XX:+InitiatingHeapOccupancyPercent （简称IHOP）：决定什么情况下发生G1 GC；<br>
-XX:MaxGCPauseMills：：期望每次GC暂定的时间，比如我们设置为50，则G1 GC会通过调节
每次GC的操作时间，尽量让每次系统的GC停顿都在50上下浮动。如果某次GC时间超过50ms， 比如说100ms，那么系统会自动在后面动态调整GC行为，围绕50毫秒浮动。
###2.4.6.年轻代模式转移暂停（Evacuation Pause）
G1 GC会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。
在应用程序刚启动时，G1还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。
**当年轻代空间用满后，应用线程会被暂停STW**，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。
拷贝的过程称为转移(Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。
###2.4.7. 并发标记（Concurrent Marking）
G1并发标记的过程与CMS基本上是一样的。G1的并发标记通过 Snapshot-At-The-Beginning(起始快照) 的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过对象的存活 信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。 这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。<br>
有两种情况是可以完全并发执行的：<br>
一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾；<br>
二、在STW转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。<br>
**当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45% ，但也可以通过JVM参数 InitiatingHeapOccupancyPercent 来设置。**
和CMS一样，G1的并发标记也是由多个阶段组成，其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。
#### 阶段 1: Initial Mark(初始标记)
此阶段标记所有从GC根对象直接可达的对象。在CMS中需要一次STW暂停，但G1里面通常是在转移暂停的同时处理这些事情，所以它的开销是很小的。
####阶段 2: Root Region Scan(Root区扫描)
此阶段标记所有从 "根区域" 可达的存活对象。
根区域包括：非空的区域，以及在标记过程中不得不收集的区域。
因为在并发标记的过程中迁移对象会造成很多麻烦，所以此阶段必须在下一次转移暂停之前完成。
如果必须启动转移暂停，则会先要求根区域扫描中止，等它完成才能继续扫描。
在当前版本的实现中，根区域是存活 的小堆块：包括下一次转移暂停中肯定会被清理的那部分年轻代小堆块。
####阶段 3: Concurrent Mark(并发标记)
此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。
为了确保标记开始时的快照准确性，所有应用线程并发对对象图执行引用更新，G1要求放弃前面阶段为了
标记目的而引用的过时引用。
####阶段 4: Remark(再次标记)
和CMS类似，这是一次STW停顿(因为不是并发的阶段)，以完成标记过程。
G1收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。
这一阶段也执行某些额外的清理，如引用处理或者类卸载(class unloading)。
####阶段 5: Cleanup(清理)
最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC的效率。
此阶段也为下一次标记执行必需的所有整理工作(house-keeping activities)：维护并发标记的内部状态。
所有不包含存活对象的小堆块在此阶段都被回收了。
有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的STW暂停，才能不受应用线程的影响并完成作业。
####转移暂停: 混合模式（Evacuation Pause (mixed)）
并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年 代区域也加入到回收集中。
混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。
比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。 
具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。
其中包括指定的软实时性 能指标，存活性，以及在并发标记期间收集的GC效率等数据，外加一些可配置的JVM选项。混合收集的过程，很大程度上和前面的 fully-young gc 是一样的。
###Remembered Sets（历史记忆集） 简介
Remembered Sets (历史记忆集) 用来支持不同的小堆块进行独立回收。<br>
例如，在回收小堆块 A、B、C时，我们必须要知道是否有从D区或者E区指向其中的引用，以确定他们的存 活性. 但是遍历整个堆需要相当长的时间，这就违背了增量收集的初衷，因此必须采取某种优化手段。类似 于其他GC算法中的“卡片”方式来支持年轻代的垃圾收集，G1中使用的则是 Remembered Sets 。 如下图所示，每个小堆块都有一个 Remembered Set ，列出了从外部指向本块的所有引用。这些引用将
被视为附加的 GC 根。注意，在并发标记过程中，老年代中被确定为垃圾的对象会被忽略，即使有外部引用 指向他们：因为在这种情况下引用者也是垃圾【如垃圾对象之间的引用或者循环引用】。

